= SIMPLE GAME - TEST REVIEW

_Besher AL ADDAM, Anis AIT YACOUB & Mattéo DERANSART_

== Liste des défauts

* Le jeu est censé débuter avec des joueurs dans l’ordre alphabétique. Par exemple, si on a 3 joueurs A, B et C, le premier joueur sera A. Initialement, le premier joueur est B. 

* Lorsqu’un pion essaye de sortir du plateau, il est censé perdre son tour. Initialement, il pouvait rejouer.

* Lorsqu’un pion se déplace vers une case vide, il est censé ne pas perdre de point de vie. Initialement, il perdait 1 point de vie.

* Le nombre de points de vie d’un pion est censé être de 6. Initialement, il a 2 points de vie. (résolu)

* Lorsqu’un pion est sur une case bonus, il perd directement 2 points de vie. Or il n’est censé infliger des dégâts que lorsqu’il attaque un autre pion.

* Lorsqu’un pion est sur une case bonus et qu’il attaque un autre pion, il est censé infligé 2 points de vie en plus. Dans le cas où l'adversaire a 1 point de vie, il est censé mourir. Or, il ne meurt pas, perd 2 points de vie et reste avec -1 point de vie.

* La couleur CYAN de `StringColoring.java` renvoie la couleur orange, PURPLE ne fonctionne pas. (PURPLE n’existe pas dans la bibliothèque Jansi, remplacée par MAGENTA)


== Analyse de la testabilité

=== Les différentes classes

== Structure et Fonctionnalités de la Classe `Board`

*Attributs et Leurs Accesseurs*::
+
--
- `xSize`, `ySize` : Dimensions du plateau, accessibles via `getXSize()` et `getYSize`.
- `pawns` : Liste des pions sur le plateau.
- `bonusSquare` : Position du carré bonus.
- `currentPawn` : Pion actuellement en train de jouer.
+
Ces attributs sont cruciaux pour déterminer l'état du jeu et sont directement liés à la logique du plateau.
--

*Constructeur*::
+
Le constructeur initialise le plateau avec une taille spécifiée, un nombre de pions, et une position de bonus aléatoire. Cette initialisation implique une certaine aléatoire, affectant la prédictibilité et la reproductibilité dans les tests.
+

*Méthodes de Gestion*::
+
- `addPawn`
- `removePawn`
- `newTurn`
- `removeAllPawns`
+
Ces méthodes modifient l'état des pions sur le plateau, nécessitant des tests pour s'assurer que les modifications d'état sont correctes.
+

*Méthodes d'Interrogation*::
+
- `getSquareContent`
- `isBonusSquare`
- `numberOfPawns`
- `maxGold`
- `getStatusOfSquare`
+
Ces méthodes fournissent des informations sur l'état actuel du plateau, et leur précision est vitale pour la logique du jeu.
+

*Représentation Visuelle*::
+
- `squareContentSprite`
- `toString`
+
Ces méthodes transforment l'état du plateau en représentations visuelles, nécessitant des tests pour vérifier leur exactitude.
+


== Analyse de la Testabilité

*Gestion de l'État et Dépendances*::
+
La classe `Board` gère un état complexe et interagit avec `Pawn` et `Position`. Des tests unitaires doivent inclure des simulations (`mocking`) pour ces classes afin de vérifier l'intégrité de l'état du plateau.
+

*Complexité des Méthodes et Scénarios de Test*::
+
Les méthodes telles que `addPawn`, `removePawn`, `newTurn`, et `getStatusOfSquare` ont une logique interne qui nécessite des tests approfondis pour couvrir tous les cas possibles.
+

*Aléatoire dans l'Initialisation*::
+
L'initialisation aléatoire des pions et de la position du bonus implique que les tests doivent être conçus pour gérer différentes configurations initiales ou contrôler l'aléatoire.
+

*Visualisation et Représentation*::
+
Tester `squareContentSprite` et `toString` exige de vérifier que la représentation textuelle ou visuelle correspond exactement à l'état actuel du plateau.
+

= Analyse de la Testabilité

== Structure et Fonctionnalités de l'Énumération `Direction`

*Simplicité*::
`Direction` est une énumération standard de Java avec quatre valeurs : `Up`, `Down`, `Left`, `Right`. Elle ne possède pas de logique interne complexe ou d'état mutable, rendant sa testabilité intrinsèquement élevée.

*Utilisation dans le Système*::
Cette énumération est utilisée pour indiquer la direction du mouvement des pions (`Pawn`) dans d'autres parties du système. Sa simplicité assure une intégration facile et fiable dans des tests unitaires ou d'intégration pour d'autres classes.

== Analyse de la Testabilité

*Pas de Logique Interne*::
`Direction`, en tant qu'énumération, ne contient pas de logique ou de méthodes internes à tester, ni d'état à vérifier, éliminant ainsi la nécessité de tests unitaires spécifiques pour cette énumération.

*Fiabilité et Consistance*::
Les énumérations en Java sont conçues pour être fiables et consistantes. Une fois définies, les valeurs de `Direction` restent inchangées et peuvent être utilisées de manière prévisible dans tout le système.

*Utilisation dans D'autres Classes*::
La testabilité de `Direction` réside principalement dans son utilisation dans d'autres classes. Il est crucial de s'assurer que les classes qui utilisent `Direction` gèrent correctement toutes ses valeurs.

== Conclusion

L'énumération `Direction` en elle-même ne nécessite pas de tests unitaires spécifiques en raison de sa nature statique et simple. L'accent doit être mis sur la manière dont `Direction` est utilisée dans d'autres parties du système, en garantissant que toutes les directions sont correctement gérées dans les scénarios de mouvement et d'interaction des pions.


== Structure et Fonctionnalités de la Classe `Game`

*Attributs*::
`board` : Cet attribut représente le plateau de jeu, une composante centrale de la classe `Game`.

*Constructeur*::
Le constructeur initialise un `Board` avec des paramètres prédéfinis, y compris la position aléatoire du bonus. Cette initialisation aléatoire peut ajouter une complexité aux tests.

*Méthodes*::
+
--
`isGameOver()` : Détermine si le jeu est terminé, basé sur le nombre de pions ou la quantité d'or accumulée.

`toString()` : Représente l'état actuel du plateau de jeu.

`playRound(Direction direction)` : Exécute un tour de jeu, impliquant soit un mouvement soit une attaque, en fonction de la direction et de l'état du plateau.
--

== Analyse de la Testabilité

*Dépendances*::
La classe `Game` dépend de `Board` et indirectement de `Pawn`. Tester `Game` implique de s'assurer que ces interactions fonctionnent comme prévu, ce qui peut nécessiter des simulations (`mocking`).

*Complexité de la Méthode `playRound`*::
Cette méthode a une logique complexe et dépend de l'état du plateau et des pions. Tester cette méthode implique de couvrir divers scénarios pour garantir une bonne couverture de test.

*Gestion des Exceptions*::
`playRound` lève des exceptions dans certaines conditions. Il est important de tester ces cas pour s'assurer que les exceptions sont lancées correctement.

*Aléatoire dans le Constructeur*::
L'utilisation de valeurs aléatoires dans le constructeur pour initialiser le plateau peut rendre les tests plus difficiles car le comportement initial du jeu peut varier.


== Structure et Fonctionnalités de la Classe `Pawn`

*Attributs et Leurs Accesseurs*::
`position`, `board`, `hitpoints`, `gold`, `letter` : Ces attributs représentent l'état du pion sur le plateau de jeu. Les accesseurs `getPosition()`, `getLetter()` et `getGold()` permettent de vérifier certains de ces états, ce qui est positif pour la testabilité.

*Constructeur*::
Le constructeur initialise l'objet `Pawn` avec plusieurs paramètres (`n`, `x`, `y`, `board`), ce qui facilite la configuration de l'état initial du pion pour les tests.

*Méthodes de Comportement*::
`move(Position p)`, `suffer(int i)`, `isDead()`, `attack(Position p)` : Ces méthodes représentent les actions principales du pion. Elles interagissent avec d'autres objets (`Board`, `Position`) et peuvent lancer des exceptions, nécessitant une attention particulière lors des tests.

== Analyse de la Testabilité

*Dépendances*::
La classe `Pawn` dépend fortement de la classe `Board` et indirectement de la classe `Position`. Cela peut compliquer les tests, nécessitant potentiellement de simuler (`mock`) ces objets pour isoler le comportement de `Pawn`.

*Gestion des Exceptions*::
Les méthodes `move` et `attack` lèvent des exceptions dans certaines conditions. Des tests spécifiques sont nécessaires pour s'assurer que les exceptions sont lancées correctement.

*Complexité des Méthodes*::
Des méthodes comme `move` et `attack` ont une logique conditionnelle complexe. Il est important de couvrir divers scénarios pour garantir une bonne couverture de test.

*Effets Latéraux et État*::
Des méthodes telles que `suffer` et `attack` modifient l'état du pion et peuvent affecter d'autres objets. Des tests doivent s'assurer que les effets latéraux sont corrects.

*Testabilité et Isolation*::
La testabilité pourrait être améliorée en rendant certaines dépendances plus facilement simulables, comme l'utilisation de l'injection de dépendances pour `Board`.

== Conclusion

La classe `Pawn` présente des défis pour la testabilité, notamment en raison de ses dépendances étroites, de la complexité de ses méthodes et de la gestion des exceptions.
Les tests unitaires pour cette classe nécessiteront probablement des techniques de simulation (`mocking`) pour isoler son comportement. Des tests d'intégration peuvent également être nécessaires pour valider les interactions entre `Pawn` et `Board`.

== Structure et Fonctionnalités de la Classe `Position`

*Attributs Privés et Méthodes d'Accès*::
+
La classe `Position` possède deux attributs privés `x` et `y` de type `int` et deux méthodes d'accès `getX()` et `getY()` qui permettent de récupérer les valeurs des attributs `x` et `y` respectivement. Cela est positif pour la testabilité car on peut vérifier l'état de l'objet après certaines opérations.

*Constructeur*::
+
La classe `Position` possède un constructeur qui prend deux paramètres `x` et `y` de type `int` et initialise les attributs `x` et `y` avec les valeurs fournies, facilitant la vérification de l'état de l'objet après l'instanciation.

*Méthode `copy()`*::
+
La classe `Position` possède une méthode `copy` qui retourne un objet de type `Position` qui est une copie de l'objet courant. Cela est positif pour la testabilité car on peut vérifier l'état de l'objet après l'opération de copie.

*Méthode `getPositionNextTo(Direction d)`*::
+
Cette méthode calcule une nouvelle position basée sur une direction donnée. Elle est simple à tester car elle ne dépend que des valeurs internes des objets `Position` et ne fait pas d'appel à des méthodes externes.

*Méthode `isNextTo(Position otherPosition)`*::
+
Cette méthode vérifie si une autre position est adjacente. Simple à tester car elle ne dépend que des valeurs internes des objets `Position` et ne fait pas d'appel à des méthodes externes.

*Méthode `equals(Object other)`*::
+
Cette méthode vérifie si une autre position est égale à l'objet courant. Elle est simple à tester car elle ne dépend que des valeurs internes des objets `Position` et ne fait pas d'appel à des méthodes externes.

== Conclusion

La classe `Position` offre une excellente testabilité grâce à ses méthodes bien conçues et à ses attributs privés bien gérés. Les modifications apportées renforcent la robustesse de la classe et facilitent les tests en couvrant plus efficacement les cas d'utilisation réels.

== Package simpleGame.cli

== Classe `CLIMain`

=== Structure et Fonctionnalités
* Gère l'interaction utilisateur dans une interface en ligne de commande.
* Dépend de `Game` pour la logique du jeu et de `InputHandler` pour la saisie utilisateur.
* Utilise une boucle pour traiter les entrées utilisateur et pour afficher l'état du jeu.

=== Analyse de la Testabilité
* *Dépendances Externes* : La classe dépend fortement de `Game` et `InputHandler`. Les mocks peuvent être nécessaires pour tester cette classe de manière isolée.
* *Gestion des Entrées Utilisateur* : Tester la gestion des entrées utilisateur peut être complexe, surtout si elle implique des interactions dynamiques.
* *Gestion des Exceptions* : Les exceptions levées par `Game` (comme `ImpossibleActionException`) doivent être prises en compte lors des tests.
* *Sortie Console* : Tester la sortie console peut nécessiter une capture de la sortie standard pour vérifier les affichages et les messages d'erreur.

== Package simpleGame.util

== Classe `CharUtil`

=== Structure et Fonctionnalités
* Fournit une méthode statique pour convertir un nombre en caractère correspondant.
* Simple et fonctionnelle, idéale pour les tests unitaires.

=== Analyse de la Testabilité
* *Simplicité* : La méthode est purement fonctionnelle, ce qui simplifie les tests.
* *Cas Limites* : Important de tester avec des valeurs limites, comme des valeurs négatives ou supérieures à 26.

== Classe `Logger`

=== Structure et Fonctionnalités
* Gère l'affichage des messages dans la console.
* Utilise `AnsiConsole` pour gérer les couleurs et les formats de texte.

=== Analyse de la Testabilité
* *Sortie Console* : Comme pour `CLIMain`, tester cette classe peut impliquer la capture de la sortie console.
* *Gestion des Couleurs* : Tester l'ajout correct des codes de couleur ANSI peut être un défi.

== Classe `StringColoring`

=== Structure et Fonctionnalités
* Permet d'ajouter des couleurs aux chaînes de caractères en utilisant des codes ANSI.
* Contient une énumération pour les couleurs supportées.

=== Analyse de la Testabilité
* *Génération des Chaînes Colorées* : Les tests doivent vérifier que la méthode génère correctement les chaînes avec les codes de couleur appropriés.
* *Variété des Couleurs* : Tester chaque couleur de l'énumération pour s'assurer que toutes sont correctement appliquées.

== Conclusion
* La testabilité de `CLIMain` est complexe en raison de ses interactions avec l'utilisateur et ses dépendances externes. Les mocks et les captures de sortie console sont essentiels pour des tests efficaces.
* Les classes utilitaires `CharUtil`, `Logger`, et `StringColoring` sont relativement plus simples à tester. `CharUtil` est idéal pour les tests unitaires, tandis que `Logger` et `StringColoring` nécessitent des tests spécifiques pour la gestion des sorties et des couleurs.


== Application d'une méthode structurelle

== Couverture de code avec Jacoco

=== Première évaluation

Voici la première couverture de code réalisée avec Jacoco:

81% de couverture de code au niveau global!
Nous n'avons testé que le module core à ce moment-là, mais il nous as semblé avoir fait la plus grosse partie du travail.

image::data/jacoco_firstGlance_global.png[]

Nous allons devoir revoir les tests de Board et de Game qui se révèlent être insuffisants. Nous sommes pourtant assez satisfait en ce qui concerne les autres classes 

image::data/jacoco_firstGlance_core.png[]

La couverture de tests n'est pas encore suffisante, nous allons devoir améliorer celà


=== Deuxième évaluation

Voici la version finale de l'évaluation de notre couverture de code:

Nous avons écris quelques tests pour le module util entre temps, mais ne sommes pas allés jusqu'à 100% de couverture de test. Certaines méthodes comme la méhode main étaient tout simplement trop difficile à tester.

image::data/jacoco_final_global.png[]

Nous avons atteint 100% de couverture de code pour le module core! C'était notre objectif de départ et nous l'avons fait.

image::data/jacoco_final_core.png[]

Nous sommes satisfait de notre couverture de code.
Si nous ne sommes pas à 100% de couverture de code sur l'ensemble du logiciel, nous considérons toutefois que c'est suffisant pour notre application.

Naivement, nous faisont confiance à ce moment la au module utils (que nous déciderons de tester plus tard, comme expliqué dans le point suivant).

Comme nous l'avons vu dans l'analyse de testabilité, le module cli quand à lui, est difficilement testable. Nous considérons qu'il est du travail du testeur "manuel" de vérifier son bon fonctionnement

== Analyse de mutation avec PIT


=== Première évaluation

La première fois que nous avons utilisé PIT à été le moment ou nous avons réalisé que nous gagnerions à tester les autres modules:

En effet, si le code du module core était plutot bien testé, rien ne nous prouve que le reste du programme fonctionne correctement.

image::data/pit_firstGlance_global.png[]

Puisque nous concentrons nos efforts sur le module core, il nous as semblé important de s'assurer que nos tests couvraient bien tout notre code.
Dans notre cas, notre couverture de test laisse passer certains mutants, nous nous sommes alors décidés à améliorer nos tests

image::data/pit_firstGlance_core.png[]

Les analyses ci-dessus nous ont prouvé que nous avions encore un peu de chemin à faire avant de considérer nos tests comme suffisants.

=== Evaluation Finale

Nous avons bien amélioré notre résistance aux mutants. de 88%, nous sommes passés à 93% de résistance aux mutants.

Tester une partie du module util nous as permis d'améliorer grandement ce score.

image::data/pit_final_global.png[]

Nous avons amélioré nos tests sur le module core pour qu'ils puissent s'adapter à un plus grand nombre de mutants.
Toutefois, nos tests ne survivent pas à certaines mutations qui prennent toutes la forme suivante:

[red]#1. removed call to simpleGame/util/Logger::log → SURVIVED#

Ces mutations suppriment certains logs, et puisqu'on ne détecte pas si un log à été affiché, le mutant n'est pas rattrapé.
Toutefois, nous considérons ces mutants comme bénins, et décidons de passer outre.

image::data/pit_final_core.png[]


== Défauts découverts

|===
|Classe |Défaut
|Game::playRound
|Il manque un break dans le switch
|Board::Board
|Parfois (mais pas tout le temps), une erreur était relevé sur la méthode testNumberOfPawns. La raison est que le constructeur faisait une boucle for aléatoirement sur le nombre de pions à initialiser.

Dans ces cas la il pouvais écraser un ou plusieur pion, ce qui fait qu'il y avait moins de pion que souhaité sur le plateau.

Nous avons donc changé la boucle for en boucle while
|Board::Board
|La case bonus était initialisé avec des valeurs de 1 à n et pas de 0 à n-1
|Board::Board
|Le contructeur incrémente le charactère du pion: A deviens B.
|
|Board::GetStatusOfSquare
| Dans la condition suivante, les cases testées à n+1 sont toujours considérées comme étant dans le tableau. +
"if (y <= this.getYSize() && x <= this.getXSize() && y >= 0 && x >= 0)"

On change la condition pour que la logueur parcourue soit strictement inférieure à la taille du tableau
|Position::isNextTo
|Dans la condition initale, on testais si une position était adjascent en x et adjascent en y. La zone pour laquelle la méthode renvoie true est donc assimilable à une croix qui parcours toute la board.

Pour que la condition se rapproche de ce qui est demandé dans la spec, on a utilisé un XOR plutôt qu'un AND
|Pawn::Pawn
|Les hitpoints initiaux étaient configurés à 2 au lieu de 6 comme marqué dans la spec
|Pawn::isDead
|Un pion doit mourir si il à des points de vie strictement inférieur à 0. Non pas égal à 0 car les hitspoints peuvent être négatifs
|GameColor
|La valeur de l'enum PURPLE dois être MAGENTA
|===


== Conclusion

En ayant passé en revue toutes les lignes de notre code non couvertes et/ou non-résilientes aux mutants, nous avons pu classer ces dernières dans deux catégories: +
    - Les instructions systemes: Nous pourrions vérifier qu'une fonction appelle bien les appels qu'elle dis appeller, mais celà nous as semblé assez peu utile. +
    - Les instructions néccessitant des entrées utilisateur: nous aurions pu mocker ces opérations, mais il nous as semblé peu interessant de le faire


Nous considérons que le travail de test automatisé est fini à ce stade.
Viens maintenant la phase ou nous devons tester manuellement le programme pour vérifier qu'il fonctionne bien.
Certes ces tests ne sont pas parfais, la preuve en est que nous avons trouvé un dernier bug en lancant la partie manuellement:

Les cases bonus ne s'affichaient que 3 fois sur 4. Il a été facile de localiser le problème, mais nos suites de tests ont du aussi être modifiées en conséquences.
(Il est à noter que nous avions trouvé le défaut mais l'avons mal corrigé à ce moment)

Toutefois ces tests n'ont pas été inutile et nous ont permis de trouver des défauts dans le code que nous n'aurions jamais pensé trouver autrement.

Les deux approches sont complémentaires